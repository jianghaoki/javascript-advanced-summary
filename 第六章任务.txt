姜豪   2018011919   6班
《JavaScript权威指南》
第八章 函数
JavaScript函数是参数化的：函数的定义会包括一个称为形参的标识符列表，
这些参数在函数体中像局部变量一样工作。
函数调用会为形参提供实参的值。
函数使用它们实⒌闹道醇扑惴祷刂担成为该函数调用表达式的值。
除了实参之外，每次调用还会拥有另一个值，本次调用的上下文，
这就是this关键字的值。
如果函数挂载在一个对象上，作为对象的一个属性，就称它为对象的方法。
在JavaScript里，函数即对象，程序可以随意操控它们。
比如，JavaScript可以把函数赋值给变量，或者作为参数传递给其他函数。
因为函数就是对象，所以可以给它们设置属性，甚至调用它们的方法。

8.1 函数定义
函数使用function关键字来定义，它可以用在函数定义表达式或者函数声明语句里。
在两种形式中，函数定义都从function关键字开始，其后跟随这些组成部分:
函数名称标识符。函数名称是函数声明语句必需的部分。
它的用途就像变量的名字，新定义的函数对象会赋值给这个变量。
对函数定义表达式来说，这个名字是可选的:
如果存在，该名字只存在于函数体中，并指代该函数对象本身。
一对圆括号，其中包含由0个或者多个用逗号隔开的标识符组成的列表。
这些标识符是函数的⑹名称，它们就像函数体中的局部变量一样。
一对花括号，其中包含0条或多条JavaScript语句。
这些语句构成了函数体: 调用函数就会执行这些语句。
以表达式方式定义的函数，函数的名称是可选的。
一条函数声明语句实际上声明了一个变量，并把一个函数对象赋值给它。
在JavaScript里，函数可以嵌套在其他函数里。

8.2 函数调用
构成函数主体的JavaScript代码在定义之时并不会执行，
只有调用该函数时，它们才会执行。
有4种方式来调用JavaScript函数:
作为函数；作为方法；作为构造函数；
通过它们的call()和app1y()方法间接调用
在一个调用中，每个参数表达式(圆括号之间的部分)都会计算出一个值，
计算的结果作为参数传递给另外一个函数。
这些值作为实参传递给声明函数时定义的形参。
在函数体中存在一个形参的引用，指向当前传入的实参列表，
通过它可以获得参数的值。
对于普通的函数调用，函数的返回值成为调用表达式的值。
如果该函数返回是因为解释器到达结尾，返回值就是undefined。
如果函数返回是因为解释器执行到一条return语句，
返回值就是return之后的表达式的值，如果return语句没有值，则返回undefined。
以函数形式调用的函数通常不使用this关键字。
不过，"this" 可以用来判断当前是否是严格模式。
大多数方法调用使用点符号来访问属性，使用方括号（的属性访问表达式）
也可以进行属性访问操作。
this是一个关键字，不是变量，也不是属性名。
JavaScript的语法不允许给this赋值。
和变量不同，关键字this没有作用域的限制，
嵌套的函数不会从调用它的函数中继承this。
如果嵌套函数作为方法调用，其this的值指向调用它的对象。
如果嵌套函数作为函数调用，其this值不是全局对象(非严格模式下)
就是undefined (严格模式下)。
如果你想访问这个外部函数的this值，需要将this的值保存在一个变量里，
这个变量和内部函数都同在一个作用域内。
通常使用变量self来保存this。

8.3 函数的实参和形参
不定实参函数的实参个数不能为零，
arguments[]对象最适合的应用场景是在这样一类函数中， 
这类函数包含固定个数的命名和必需参数，以及随后个数不定的可选实参。
arguments并不是真正的数组，它是一个实参对象。
每个实参对象都包含以数字为索引的一组元素以及length属性，
但它毕竟不是真正的数组。
在非严格模式下，当一个函数包含若千形参，
实参对象的数组元素是函数形参所对应实参的别名，
实参对象中以数字索引，并且形参名称可以认为是相同变量的不同命名。
通过实参名字来修改实参值的话，通过arguments[]数组也可以获取到更改后的值。
8.4 作为值的函数
可以将函数赋值给变量，储存在对象的属性或数组的元素中，
作为参数传入另外一个函数等。
除了可以将函数赋值给变量，同样可以将函数赋值给对象的属性。
当函数作为对象的属性调用时，函数就称为方法、

8.6 闭包
函数对象可以通过作用域链互相关联起来，
函数体内部的变量都可以保存在函数作用域内，这种特性称为“闭包”
每个函数调用都包含一个this值，如果闭包在外部函数里是无法访问this的，
除非外部函数将this转存为一个变量。
8.7 函数属性、方法和构造函数
在函数体里，arguments. length表示传入函数的实参的个数。
而函数本身的length属性则有着不同含义。
函数的length属性是只读属性，它代表函数实参的数量，
这里的参数指的是“形参”而非“实参”，也就是在函数定义时给出的实参个数，
通常也是在函数调用时期望传入函数的实参个数。
可以将call()和apply()看做是某个对象的方法，
通过调用方法的形式来间接调用函数。
call()和apply()的第一个实参是要调用函数的母对象，
它是调用上下文，在函数体内通过this来获得对它的引用。
apply()方法和call()类似，但传入实参的形式和call()有所不同，
它的实参都放入一个数组当中。
如果一个函数的实参可以是任意数量，给apply()传入的参数数组可以是任意长度的。
比如，为了找出数组中最大的数值元素，
调用Math.max()方法的时候可以给apply()传入一个包含任意个元素的数组。
Function()构造函数可以传入任意数量的字符串实参，
最后一个实参所表示的文本就是函数体;
它可以包含任意的JavaScript语句，每两条语句之间用分号分隔。
传入构造函数的其他所有的实参字符串是指定函数的形参名字的字符串。
如果定义的函数不包含任何参数，只须给构造函数简单地传入一个字符串即可。
Function()构造函数并不需要通过传入实参以指定函数名。
就像函数直接量一样，Function()构造函数创建-个匿名函数。

《深入理解JavaScript》
第15章 函数
为完成某一功能的程序指令(语句)的集合，称为函数。
JavaScript函数的分类
1、自定义函数(我们自己编写的函数)，如：function funName(){}
2、系统函数(JavaScript自带的函数)，如alert函数。
函数的调用方式
1、普通调用：functionName(实际参数...)
2、通过指向函数的变量去调用：
var myVar=函数名;myVar(实际参数...);
函数返回值
1.当函数无明确返回值时，返回的值就是"undefined"。
2.当函数有返回值时，返回值是什么就返回什么。
函数的参数列表可以是任意多个，并且数据类型可以是任意的类型，
JavaScript的函数天然支持可变参数，
JavaScript有一个arguments变量可以访问所有传到函数内部的参数。
JavaScript支持创建动态函数，动态函数必须用Function对象来定义
（Function是javascript中的一个对象，是固定不变的，
规定Function对象的"F"必须大写）
使用new关键字（new是javascript中一个关键字，也是固定的，
我们在定义动态函数的时候必须要使用new来创建这个Function对象）
定义一个变量：var 变量名，在这里变量名是随便的，
然后我们再使用new关键字创建一个Function对象，
然后再把这个对象赋值给这个任意的变量。
square是动态创建的函数，在Function对象后面的括号里的每一部分内容
都必须是字符串形式的，也就是说都必须用引号（""或者是''）括起来
把一个字符串分成了若干个独立的字符串的优点就在于
我们可以通过修改其中的某些字符串来随时改变函数的作用。
直接声明一个匿名函数，立即使用。用匿名函数的好处就是省得定义
一个用一次就不用的函数，而且免了命名冲突的问题，js中没有命名空间的概念，
因此很容易函数名字冲突，一旦命名冲突以最后声明的为准。
JavaScript没有方法重载的说法，如果两个方法名字一样，即使参数个数不一样，
那么后面定义的就会覆盖前面定义，调用方法时永远是调用后定义的那个。
可以将call()和apply()看做是某个对象的方法，
通过调用方法的形式来间接调用函数。
call()和apply()的第一个实参是要调用函数的母对象，
它是调用上下文，在函数体内通过this来获得对它的引用。
apply()方法和call()类似，但传入实参的形式和call()有所不同，
它的实参都放入一个数组当中。

第16章 变量：作用域、环境和闭包
每个执行环境都有一个与之关联的变量对象，
环境中定义的所有变量和函数都保存在这个变量中。
虽然我们编写的代码无法访问这个对象，但解析器在处理数据时会在后台使用它。
每个函数都有自己的执行环境，当执行流进入一个函数时，
函数的环境就会被推入一个环境栈中。而在函数执行后，栈将其环境弹出，
把控制权返回给之前的执行环境。
执行环境始终是this关键字的值，它是拥有当前所执行代码的对象的引用。
执行环境是基于对象来说的，比如 window对象在全局环境中。
执行环境可以分为执行和创建两个阶段。
1.创建阶段（当函数被调用，但未执行任何其内部代码之前），
解析器首先会创建一个变量对象,它由定义在执行环境中的变量。
函数声明，参数组成。作用域链会被初始化，this的值也会被确定。
2.执行阶段：初始化变量的值和函数的引用，代码被解释执行。
JavaScript的执行环境中都有个对象用来存放执行环境中可被访问
但是不能被delete的函数标识符、形参、变量声明等。
它们会被挂载这个叫做”变量对象“的对象上，对象的属性对应它们的名字，
属性的值对应它们的值。这个对象是在规范上的不可在JS环境中访问到的活动对象。
每进入一个执行环境，这个执行环境中的变量就被激活，
也就是该执行环境中的函数标识符，形参，变量声明等就可以被访问到了。
活动对象是被激活的变量对象。
简单来说，作用域就是变量与函数的可访问范围。
即作用域控制着变量与函数的可见性和声明周期。
作用域分为哪几种：
全局作用域：在代码中任何地方都能访问到的对象拥有全局作用域
最外层函数和在最外层函数外面定义的变量拥有全局作用域
所有未定义直接赋值的变量自动声明为拥有全局作用域
所有window对象的属性拥有全局作用域。
局部作用域（函数作用域）：一般只在固定的代码片段内可访问到，
而对于函数外部是无法访问的。在函数内部声明的变量及函数。
作用域链
来自JS高设--当代码在一个环境中执行的时候，会创建变量对象的一个作用域链。
作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。
作用域链的前端，始终都是当前执行的代码所在环境的变量对象。
如果这个环境是函数，则将其活动对象作为变量对象。
活动对象最开始时只包含一个变量，即arguments对象
（这个对象在全局环境中是不存在的），而作用域链中的下一个变量对象来自包含
（外部）环境，再下一个变量对象则来自下一个包含环境。
这样一直延续到全局执行环境；
全局执行环境的变量对象始终都是作用域链中的最后一个对象。
理解--根据内部函数可以访问外部函数变量的这种机制，
所有可被内部函数访问的变量在被访问时会根据一种链式机制来进行访问，
而这种包含且由有权访问的变量组成的链式机制，就称为作用域链。
作用域链的本质是一个指向变量对象的指针列表，它只引用但不实际包含变量对象。
闭包，即有权访问其他函数作用域内变量的一个函数，
本质上是将函数内部和外部连接起来的一座桥梁。
js函数内的变量值不是在编译的时候就确定的，而是等在运行时期才去寻找的。
且由于作用域链的本质是一个指向变量对象的指针列表，
所以有一个副作用，就是闭包只能取得包含函数中任何变量的最后一个值。
总结--闭包的两个作用
可以在函数内部读取函数外部的变量
可以让这些变量一直保存在内存中











