姜豪   2018011919   6班
《你不知道的JavaScript（上卷）》
第一章 作用域是什么
引擎从头到尾负责整个JavaScript程序的编译及执行过程。
作用域负责收集并维护由所有声明的标识符（变量）组成的一系列查询，
并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。
变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量
（如果之前没有声明过），然后在运行时引擎会在作用域中查找该变量，
如果能够找到就会对它赋值。
当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。
在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，
直到找到该变量，或抵达最外层的作用域（全局作用域）为止。
遍历嵌套作用域链的规则：引擎从当前的执行作用域开始查找变量，
如果找不到，就向上一级继续查找。当抵达最外层的全局作用域时，
无论找到还是没找到，查找过程都会停止。
作用域是一套规则，用于确定在何处以及如何查找变量（标识符）。
如果查找的目的是对变量进行赋值，那么就会使用LHS查询；
如果目的是获取变量的值，就会使用RHS查询。
赋值操作符会导致LHS查询。=操作符或调用函数时传人参数的操作
都会导致关联作用域的赋值操作。
JavaScript引擎首先会在代码执行前对其进行编译，
在这个过程中，像var a = 2这样的声明会被分解成两个独立的步骤:
1.首先，var a在其作用域中声明新变量。这会在最开始的阶段，
也就是代码执行前进行。2.接下来，a=2会查询(LHS查询)变量a并对其进行赋值。
不成功的RHS引用会导致抛出ReferenceError异常。
不成功的LHS引用会导致自动隐式地创建-一个全局变量(非严格模式下)，
该变量使用LHS引用的目标作为标识符，或者抛出ReferenceError异常(严格模式下)。

第2章 词法作用域
作用域有两种主要的工作模型，一种是词法作用域，另一种是动态作用域。
作用域查找会在找到第一一个匹配的标识符时停止。
在多层的嵌套作用域中可以定义同名的标识符，这叫作“遮蔽效应”
(内部的标识符“遮蔽”了 外部的标识符)。
抛开遮蔽效应，作用域查找始终从运行时所处的最内部作用域开始，
逐级向外或者说向上进行，直到遇见第一个匹配的标识符为止。
全局变量会自动成为全局对象(比如浏览器中的window对象)的属性，
因此可以不直接通过全局对象的词法名称，
而是间接地通过对全局对象属性的引用来对其进行访问。
无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由
函数被声明时所处的位置决定。词法作用域查找只会查找一级标识符。
JavaScript 中的 eval(..) 函数可以接受一个字符串为参数。
尽管 with 块可以将一个对象处理为词法作用域，但是这个块内部正常的 var
声明并不会被限制在这个块的作用域中，而是被添加到with所处的函数作用域中。
词法作用域意味着作用域是由书写代码时函数声明的位置来决定的。
JavaScript 中有两个机制可以“欺骗”词法作用域：eval(..) 和 with。
前者可以对一段包含一个或多个声明的“代码”字符串进行演算，
并借此来修改已经存在的词法作用域（在运行时）。
后者本质上是通过将一个对象的引用当作作用域来处理，将对象的属性
当作作用域中的标识符来处理，从而创建了一个新的词法作用域（同样是在运行时）。

第3章 函数作用域和块作用域
函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用
及复用（事实上在嵌套的作用域中也可以使用）。
“隐藏”作用域中的变量和函数所带来的另一个好处，
是可以避免同名标识符之间的冲突，两个标识符可能具有相同的名字但用途却不一样，
无意间可能造成命名冲突。冲突会导致变量的值被意外覆盖。
函数声明和函数表达式之间最重要的区别是它们的名称标识符将会绑定在何处。
函数表达式可以是匿名的，而函数声明则不可以省略函数名，
在 JavaScript 的语法中这是非法的。
JavaScript的ES3规范中规定try/catch的catch分句会创建一个块作用域，
其中声明的变量仅在catch内部有效。
只要声明是有效的，在声明中的任意位置都可以使用{ .. }括号来为let
创建一个用于绑定的块。
函数是 JavaScript 中最常见的作用域单元。
本质上，声明在一个函数内部的变量或函数会在所处的作用域中“隐藏”起来。
但函数不是唯一的作用域单元。块作用域指的是变量和函数不仅可以属于所处的作用域，
也可以属于某个代码块（通常指 { .. } 内部）。

第4章 提升
函数作用域和块作用域的行为是一样的，可以总结为：
任何声明在某个作用域内的变量，都将附属于这个作用域。
只有声明本身会被提升，而赋值或其他运行逻辑会留在原地。
如果提升改变了代码执行的顺序，会造成非常严重的破坏。
每个作用域都会进行提升操作。尽管前面大部分的代码片段已经简化了
（因为它们只包含全局作用域）
即使是具名的函数表达式，名称标识符在赋值之前也无法在所在作用域中使用。
无论作用域中的声明出现在什么地方，都将在代码本身被执行前首先进行处理。
可以将这个过程形象地想象成所有的声明（变量和函数）都会被“移动”
到各自作用域的最顶端，这个过程被称为提升。
声明本身会被提升，而包括函数表达式的赋值在内的赋值操作并不会提升。

第5章 作用域闭包
当函数可以记住并访问所在的词法作用域时，就产生了闭包，
即使函数是在当前词法作用域之外执行。
函数 bar() 的词法作用域能够访问 foo() 的内部作用域。
在 foo() 执行后，通常会期待 foo() 的整个内部作用域都被销毁，
因为我们知道引擎有垃圾回收器用来释放不再使用的内存空间。
这个函数在定义时的词法作用域以外的地方被调用。
闭包使得函数可以继续访问定义时的词法作用域。
当然，无论使用何种方式对函数类型的值进行传递，
当函数在别处被调用时都可以观察到闭包。
无论通过何种手段将内部函数传递到所在的词法作用域以外，
它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包。
模块模式需要具备两个必要条件。
1. 必须有外部的封闭函数，该函数必须至少被调用一次
（每次调用都会创建一个新的模块实例）。
2. 封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，
并且可以访问或者修改私有的状态。
一个具有函数属性的对象本身并不是真正的模块。从方便观察的角度看，
一个从函数调用所返回的，只有数据属性而没有闭包函数的对象并不是真正的模块。
模块有两个主要特征：（1）为创建内部作用域而调用了一个包装函数；
（2）包装函数的返回值必须至少包括一个对内部函数的引用，
这样就会创建涵盖整个包装函数内部作用域的闭包。