姜豪   2018011919   6班
《深入理解JavaScript》
第17章 对象与继承
JavaScript中的面向对象编程分为如下几层：
第一层：单一对象的面向对象。
第二层：对象间的原型链。
第三层：作为实例工厂的构造函数，类似于其他语言中的类。
第四层：子类，通过继承已有的构造函数，创建新的构造函数。
每一层都依赖于前一层，第一层和第二层构成了基本核心。
17.1 第一层：单一对象
JavaScript中所有的对象都是从字符串到值的映射。
一个对象中的某一项（键、值）称为属性。属性的键始终是文本字符串。
属性的值可以是任何JavaScript值，包括函数。方法是值为函数的属性。
属性可以分为三类：
(1)属性（数据属性）
对象中的普通属性(即从字符串的键到值的映射)，包括方法被称为数据属性。
这是到目前为止最常见的属性类型。
(2)访问器(访问器属性)
访问器是类似于读、写属性的特殊方法。
属性的值存储在普通属性中，而访问器可以计算属性的值。
(3)内置属性
只存在于ECMAScript语言规范中。
它们不能用JavaScript直接访问，但也许可以用间接的方式访问。
规范将内置属性的键置于方括号中。

JavaScript的对象字面量可以直接创建简单对象(Object的直接实例)。
点操作符提供了一种简洁的语法访问属性。属性的键必须是标识符。
点操作符可以“获取”一个属性（读取它的值）。
获取一个不存在的属性会返回undefined。
点操作符也可以用于调用方法。
可以使用赋值操作符（=）为点操作符指向的属性赋值。
如果一个属性不存在，给它赋值时会自动创建该属性。
如果一个属性已经存在，给它赋值时会改变该属性的值。
delete操作符允许从一个对象中完全移除一个属性（整个键-值对）。
如果只是把一个属性设置为undefined，这个属性仍然存在，
这个对象仍然包含这个键。如果删除这个属性，它的键就不存在了。
删除只影响一个对象的直接（非继承的）属性，并不涉及它的原型。
如果属性是自有属性，且不能被删除，delete会返回false。
delete不能删除自有属性时，返回false。，其他所有情况下删除属性，返回true
delete操作即使没有产生任何变化，也会返回true（继承的属性不会被移除）
在对象字面量中，数字也可以用来作为属性的键，但它们会被解析为字符串。
点操作符只能访问键为标识符的属性。
你需要使用中括号操作符来访问键为数字的属性。
对象字面量也可以使用任意字符串(既不是标识符也不是数字)作为属性的键，
但你必须加上引号，而且你需要使用中括号操作符来访问这些属性的值。
点操作符需要使用固定的属性键，而中括号操作符可以通过表达式引用一个属性
中括号操作符可以通过表达式计算得出一个属性的键。
该操作符也可以通过非标识符的键访问属性。
中括号操作符强制括号中的内容转化为字符串。

17.2 把任意值转化为对象
笼统的说，JavaScript中所有的对象都是从字符串（string）到值（value）的映射。
一个对象中的某一项（键、值）成为属性。属性的键（key）始终是文本字符串。
属性的值（value）可以是任意JavaScript值，包括函数。方法是值为函数的属性。
属性可以分为3种：
① 属性： 对象中的普通属性（即从字符串的键到值得映射），
包括方法被称为数据属性。这是目前为止最常见的属性类型。
② 访问器： 访问器是类似于读、写属性的特殊方法。属性的值存储在普通属性中，
而访问器可以计算属性的值。你可以把它们看做是虚拟的属性。
③ 内置属性： 只存在于ECMAScript语言规范中。它们不能用JavaScript直接访问，
但也许可以用间接的方式访问。规范将内置属性的键置于方括号中。
JavaScript的对象字面量可以直接创建简单对象。
在方法中使用this来指代当前对象（也被称为方法调用的接受者）。
点运算符（.）： 通过固定键值访问属性。
如果一个属性不存在时，那么会自动创建该属性；如果存在这个属性，那么就改变它的值。
删除属性：通过delete操作符允许你从一个对象中完全移除一个属性（整个键-值对）。
而这种删除只影响一个对象的直接属性，而不涉及它的原型。
在对象字面量中，你可以使用数字作为属性的键，但它们会被解析为字符串。
当然你也可以使用任意字符串来作为键，但是你必须加上引号。

17.3 this作为函数和方法的隐式参数
当你调用一个函数时，this总是作为一个（隐式）参数。
1. 宽松模式中的普通函数
尽管普通函数中的this没有实际用处，但它仍能作为一个特殊的变量存在，
它的值总是指向全局对象。
2. 严格模式中的普通函数 this总是undefined。
this总是指向调用方法的对象。
函数也是对象。因此，每个函数都有自己的方法。
① Function.prototype.call(thisValue,arg1?,arg2?,...)
第一个参数会赋值给被调用函数内的this；剩下的参量作为参数传入被调函数。
② Function.prototype.apply(thisValue,argArray)
第一个参数会赋值给被调函数内的this；第二个参数是一个数组，为被调用函数提供参数。
③ Function.prototype.bind(thisValue,arg1?,...,argN?)
这个方法展示了偏函数应用――意味着它创建了一个新的函数，
并用接下来的方式调用bind()的接受者：this的值是thisValue，参数从arg1到argN，
紧随其后的是新函数的参数。换句话说，当调用原来的函数时，
新函数将其参数追加到arg1，...argN的后面。

17.4 对象间的原型关系
两个对象间的原型关系类似继承：每个对象都可以把另一个对象作为它的原型，
并继承原型的所有属性。对象通过内部属性[[prototype]]指定它的原型。
每隔对象都有这个属性，而它也可以是null。
通过[[prototype]]属性连接成的原型成为原型链。
obj继承了describe。你可以访问这个属性，就像对象本身拥有该属性一样。
当你通过obj访问属性时，JavaScript首先从本对象中查找，接着是它的原型，
以及原型的原型，以此类推。原型链的行为好像是一个单独的对象。
当你调用一个方法时，容易出错是因为this的值总是开始查找方法时所在的那个对象，
而不是找到方法时所在的对象。
在一个原型链中，一个对象的属性可以覆写“之后”对象的相同键的属性：
前者的属性最先被找到。它隐藏了后者的属性，这样后者的属性就不能被访问了。
通过原型在对象间共享数据
原型对于对象间数据共享十分有用：多个对象可以有相同的原型，
这个原型持有所有的共享属性。
获取和设置原型
① 使用给定prototype创建新对象
调用方法： Object.create(proto,propDescObj?)
② 读取对象原型
调用方法： Object.getPrototypeOf(obj)，返回obj的原型。
③ 检查一个对象是否是另一个对象的原型
调用方法： Object.prototype.isPrototypeOf(obj)，检查方法的接收者是否是obj的
（直接或间接）原型。
换句话说，接收者和obj是否在同一原型链上，且obj是否在接受者之前。
④ 特殊属性__proto__
某些JavaScript引擎有特殊属性可以获取和设置对象的原型：__proto__。
这样就可以直接访问[[prototype]]。
关于__proto__，你需要知道以下几点：
1. __proto__读作“dunder proto”，“double underscore proto”的缩写。
2. __proto__不属于ECMAScrip5标准。
3. 然而，越来越多的引擎开始支持__proto__，而它也将成为ECMAScrip6的一部分。
4. 下面的表达式检测引擎是否支持__proto__：

17.5 遍历和检测属性
设置和删除仅影响自有属性
① 设置属性
原型属性会由多个对象共享。这种方式不会让我们破坏、“改变”原有属性，
而只是影响当前对象。
② 删除继承的属性
你只能删除自有属性，而不能删除继承属性。
③ 在原型链的任何位置改变属性
如果你希望改变继承的属性，首先就是找到拥有这个属性的对象，
然后改变这个对象的相应属性。
遍历和检测属性的相关操作受如下情况影响。
1. 继承（自由属性和继承属性）
一个对象的自有属性直接存储在该对象中。继承的属性存储在该对象的其中一个原型中。
2. 枚举（枚举属性和非枚举属性）
属性的枚举是一个特性，标识为true或false。①  列出自有的属性键
你可以列出所有自有的属性键，也可以只列出可枚举的属性键
Object.getOwnPropertyNames(obj)：返回obj的所有自有的属性键。
Object.keys(obj)：返回所有可枚举的属性键。
注：属性通常都是可枚举的，因此你可以使用Object.keys()，特别是对已创建的对象。
② 列出所有的属性键
如果你想列出所有的属性键（包括自有的和继承的），有两个选择。
第一种就是使用for-in循环。
第二种就是自己实现一个函数，遍历所有属性键（不仅是可枚举的）。

17.7 访问器
对象属性是名字、值和一组属性描述符构成的。
而属性值可以用一个或两个方法代替，
这两个方法是getter和setter而这种属性类型叫访问器属性。
【1】：configurable（可配置性）
可配置性决定是否可以使用delete删除属性，以及是否可以修改属性描述符的特性，默认为true。
【2】：enumerable（可枚举性）
可枚举性决定属性是否出现在对象的属性枚举中，
比如是否可以通过for-in循环遍历并返回该属性，默认值为true。
【3】：getter
在读取属性时调用的函数。默认值为undefined。
【4】：setter
在写入属性值时调用的函数，默认值时undefined。
和数据属性不同，访问器属性不具有可写性。
如果属性同时具有getter和setter方法，那么它是一个读/写属性。
如果它只有getter方法，那么它是一个只读属性。
如果它只有setter方法，那么它是一个只写属性。
读取、只写属性（意味着没有写入值）总是返回undefined。
设置writable:false后，通过Object.defineProperty()方法改变属性value的值
不会受影响，因为这也意味着在重置writable的属性值为false

17.8 属性特性和属性描述符
可写性：决定是否可以修改属性的值，默认是true。
可配置性:可配置性决定是否可以使用delete删除属性，
以及是否可以修改属性描述符的特性，默认值为true。
【1】：设置configurable:false后，无法使用delete删除属性。
在严格模式下删除configurable:false的属性，会提示类型错误的TypeError。
[注意点]：使用var命令声明变量时，变量的configurable为false。
一般的，设置configurable:false后，将无法再使用defineProperty()方法来修改属性描述符。
设置Configurable:false后，只允许writable的状态从true变为false。
可枚举性:可枚举性决定属性是否出现在对象的枚举属性中，
具体来说就是for-in循环、Object.keys()方法、JSON.stringify()方法是否会取到该属性。
用户定义的普通属性默认是可枚举的，而原生继承的属性默认是不可枚举的。
get是一个隐藏的函数，在获取属性值时调用。
set也是一个隐藏函数，在设置值时调用，它们的默认值都是undefined。

17.14 所有对象的方法
Object.definedProperty()中的get和set对应于对象字面量中get和set方法，
[注意]getter和setter取代了数据属性中的value和writable属性。
Object.getOwnPropertyDescriptor(obj,name)：
用于查询一个属性的描述符，并以对象的形式返回。
Object.defineProperty(obj,name,desc)：
用于创建或配置对象的一个属性描述符，返回配置后的对象。
Object.defineProperty(o,desc)：
用于创建或配置对象的多个属性的描述符，然后返回配置后的对象。
Object.create(proto,desc)使用指定的原型和属性来创建一个对象。
Object.freeze()【对象冻结】：使一个对象不可扩展、不可配置、也不可改写、
变成一个仅仅可以枚举的只读常量，并返回当前对象。
Object.isFrozen()【监测是否被冻结】
在严格模式下，删除旧属性，添加新属性，更改现有属性都会报错。

17.16 缺陷：Object作为Map使用
缺陷1:继承影响读取属性
读取属性的操作可以分为两种类型。
一些操作涉及整个原型链和继承的属性。
其他操作只访问对象自有的(非继承的)属性。
obj是拥有一个自有属性的对象，它的原型是proto，且这个原型也具有一个自有属性。
proto的原型是object.prototype,像所有由对象字面量创建的对象一样。
因此，obj继承了proto和0bj ect. prototype的属性。
缺陷2：覆写会影响调用方法
缺陷3：特殊属性_proto_


