姜豪   2018011919   6班
《你不知道的JavaScript（中卷）》
第一章 类型
1.2 内置类型
JavaScript有七种内置类型：
空值（null）、未定义（undefined）、布尔值（boolean）、
数字（number）、字符串（string）、对象（object）、符号（symlbol）
除对象之外，其他统称为“基本类型”。
可以用typeof运算符来查看值的类型，它返回的是类型的字符串值。
null是基本类型中唯一的“假值”类型，typeof对它的返回值为“object”
函数不仅是对象，还可以拥有属性。

1.3 值和类型
JavaScript中的变量是没有类型的，只有值才有。
类型定义了值的行为特征。
变量可以随时持有任何类型的值。
变量在未持有值的时候为undefined，此时typeof返回“undefined”
浏览器中的全局对象是window。

第二章 值
2.1 数组
数组（array）、字符串（string）和数字（number）
是一个程序最基本的组成部分。
在JavaScript中，数组可以容纳任何类型的值。
使用delete运算符可以将单元从数组中删除，
单元删除后，数组的length属性并不会发生变化。
数组通过数字进行索引，它们也是对象，也可以包含字符串键和属性。
建议使用对象来存放键值/属性值，用数组来存放数字索引值。
将类数组（一组通过数字索引的值）转换为真正的数组，
一般通过数组工具函数（如indexOf(..)concat(..)forEach(..)等）来实现。
2.2 字符串
字符串和数组都是类数组，都有length属性以及indexof（..）和concat（..）方法
JavaScript中字符是不可变的，而数组是可变的。
字符串不可变是指字符串的成员函数不会改变其原始值，
而是创建并返回一个新的字符串，数组的成员函数都是在其原始值上进行操作。
2.3 数字
JavaScript只有一种数据类型：number（数字），包括“整数”和带小数的十进制。
JavaScript使用的是“双精度”格式。
JavaScript中的数字常量一般用十进制表示。
数字前面的0可以省略，小数点后小数部分最后面的0也可以省略。
默认情况下大部分数字都以十进制显示，小数部分最后面的0被省略。
特别大的和特别小的数字默认用指数格式显示，与toexponential（）函数的输出结果相同
要检测一个值是否是整数，可以使用number.isInteger(..)方法
虽然整数最大能够达到53位，但是有些数字操作只适用于32位数字。
undefined和null类型只有一个值。
null指空值，undefined指没有值。
NaN是一个特殊值，它和自身不相等，是唯一一个非自反的值。
JavaScript有一个常规的+0和一个-0
2.5 值和引用
简单值总是通过值复制的方式来赋值/传递，包括null、undefined、字符串、数字、布尔、和symbol
复合值―对象和函数，则总是通引用复制的方式来赋值/传递。
我们无法自行决定使用值复制还是引用复制，一切由值的类型来决定。
如果通过复制的方式来传递复合值，就需要为其创建一个复本，这样传递的就不再是原始值。
如果要将标量基本类型值传递到函数内并进行更改，
就需要将该值封装到一个复合值中，然后通过引用复制的方式传递。
正无穷Infinity，负无穷-Infinity

第四章 强制类型转换
4.1 值类型转换
将值从一种类型转换为另一种类型通常称为类型转换（type casting），
这是显式的情况；隐式的情况称为强制类型转换。
JavaScript中的强制类型转换总是返回标量基本类型值，
如字符串、数字和布尔值，不会返回对象和函数。
4.2 抽象值操作
抽象操作 ToString它负责处理非字符串到字符串的强制类型转换。
基本类型值的字符串化规则为：null 转换为 "null"，
undefined 转换为 "undefined"，true转换为 "true"。
JSON.stringify(..)在对象中遇到 undefined、function和symbol时会自动将其忽略，
在数组中则会返回 null（以保证单元位置不变）。
如果 replacer 是一个数组，那么它必须是一个字符串数组，
其中包含序列化要处理的对象的属性名称，除此之外其他的属性则被忽略。
JavaScript 中的值可以分为以下两类：
(1) 可以被强制类型转换为 false 的值
(2) 其他（被强制类型转换为 true 的值）
假值的布尔强制类型转换结果为 false。
4.3 显式强制类型转换
们不建议对日期类型使用强制类型转换，应该使用Date.now() 来获得当前的时间戳，
使用 new Date(..).getTime() 来获得指定时间的时间戳。
ToInt32首先执行ToNumber强制类型转换，比如 "123" 会先被转换为 123，
然后再执行ToInt32。
indexOf(..) 不仅能够得到子字符串的位置，还可以用来检查字符串中是否
包含指定的子字符串，相当于一个条件判断。
如果indexOf(..) 返回 -1，~将其转换为假值0，其他情况一律转换为真值。
解析允许字符串中含有非数字字符，解析按从左到右的顺序，
如果遇到非数字字符就停止。而转换不允许出现非数字字符，
否则会失败并返回 NaN。
解析字符串中的浮点数可以使用 parseFloat(..) 函数。
建议使用 Boolean(a) 和 !!a 来进行显式强制类型转换。
下面的情况会发生布尔值隐式强制类型转换：
(1) if (..) 语句中的条件判断表达式。
(2) for ( .. ; .. ; .. ) 语句中的条件判断表达式（第二个）。
(3) while (..) 和 do..while(..) 循环中的条件判断表达式。
(4) ? : 中的条件判断表达式。
(5) 逻辑运算符||（逻辑或）和&&（逻辑与）左边的操作数（作为条件判断表达式）。
|| 和 && 首先会对第一个操作数（a 和 c）执行条件判断，
如果其不是布尔值（如上例）就先进行ToBoolean强制类型转换，然后再执行条件判断。
符号不能够被强制类型转换为数字（显式和隐式都会产生错误），
但可以被强制类型转换为布尔值（显式和隐式结果都是true）。
4.5　宽松相等和严格相等
null 和 undefined 之间的 == 也涉及隐式强制类型转换。
(1) 如果 x 为 null，y 为 undefined，则结果为 true。
(2) 如果 x 为 undefined，y 为 null，则结果为 true。
关于对象（对象/函数/数组）和标量基本类型（字符串/数字/布尔值）之间的相等比较：
(1) 如果Type(x) 是字符串或数字，Type(y) 是对象，则返回 x==ToPrimitive(y) 的结果；
(2) 如果Type(x) 是对象，Type(y)是字符串或数字，则返回 ToPromitive(x)==y 的结果。





























